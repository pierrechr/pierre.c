#  SageMath version 10.4

from random import randint
import time

#  Curve-ID: brainpoolP256t1 from https://www.ietf.org/rfc/rfc5639.txt

p = 0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377
a = 0xA9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5374
b = 0x662c61c430d84ea4fe66a7733d0b76b7bf93ebc4af2f49256ae58101fee92b04
G = (0xa3e8eb3cc1cfe7b7732213b23a656149afa142c47aafbc2b79a191562e1305f4,         0x2d996c823439c56d7f7b22e14644417e69bcb6de39d027001dabe8f35b25c9be)
n = 0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7

# Define base field and curve in Sage

k  = GF(p)
E = EllipticCurve(k,[a,b])
G = E(G)

# Checks that the order of G given as reference matches

assert G.order() == n

# Ask for the twists
# Checks that E is E1 and E2 its quadratic twist Et (there is no guarantee about the order of the curves outputed by E.twists)

E1,E2 = E.twists()
if E1 != E:
    E1,E2 == E2,E1

# Factor their order using Elliptic Curve Method.
# According to Sage documentation
# """"The elliptic curve factorization method (ECM) is the fastest way to factor a known composite integer if one of the factors is
#     relatively small (up to approximately 80 bits / 25 decimal digits). """"

n1 = E1.order()
n2 = E2.order()
l1 = ecm.factor(n1)
l2 = ecm.factor(n2)

# brainpoolP256t1 has prime order but it's twist has 6 out of 7 relatively small prime factors.
# 2**42 make Baby Step Giant Step possible

print("[+] Prime facorization of the curve's order :", l1)
print("and of it's twist :", l2)
print("Bit length of the primes appearing above :")
[a.bit_length() for a in l1]
[a.bit_length() for a in l2]

# For example work ina subgroup of order 4233394996199 in Et

print("[+] Restricting to the subgroup of order 4233394996199 on the twist")
cofactor = 4233394996199
Gt = E2.gens()[0]
h = n2//cofactor
P = Gt*h
assert P.order() == cofactor

# Generate a challenge DLP in the group generated by P and solve it using the log method

print("[+] Generating a challenge for DLP")
k = randint(1,cofactor)
B = k * P
print("[+] Solving this DLP")
t = time.time()
d = B.log(P)
print("Time to solve the DLP :", round(time.time() -t,3) ,"sec")
print("Successfully solved the DLP  :", d == k)

# Compare with discrete_log method
### Uncomment this if you want to compare, but this method is way too greedy
##
###k = randint(1,cofactor)
###B = k * P
##
###t = time.time()
###d = discrete_log(B,P,operation="+")
###print("Time to solve the DLP :", round(time.time() -t,3) ,"sec")
###print("Successfully solved the DLP :", d == k)




# Investigating twists and morphisms

d = -1
legendre_symbol(d,p)
Et = EllipticCurve(k,[a*d**2,b*d**3])
assert Et.is_isomorphic(E2)
phi = Et.isomorphism_to(E2)
u = phi.u
legendre_symbol(u,p)

k2 = GF(p**2)
assert Et.is_isomorphic(E1) == False
Etk2 = Et.base_extend(k2)
Ek2 = E1k2.base_extend(k2)
assert Etk2.is_isomorphic(E1k2)
psi = Etk2.isomorphism_to(E1k2)
u = psi.u
legendre_symbol(u,p)








